import { useState, useCallback, useRef, useEffect } from 'react'\n\n/**\n * Custom hook for debouncing values\n * @param {any} value - Value to debounce\n * @param {number} delay - Delay in milliseconds\n * @returns {any} Debounced value\n */\nexport const useDebounce = (value, delay) => {\n  const [debouncedValue, setDebouncedValue] = useState(value)\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value)\n    }, delay)\n\n    return () => {\n      clearTimeout(handler)\n    }\n  }, [value, delay])\n\n  return debouncedValue\n}\n\n/**\n * Custom hook for throttling functions\n * @param {Function} callback - Function to throttle\n * @param {number} delay - Delay in milliseconds\n * @returns {Function} Throttled function\n */\nexport const useThrottle = (callback, delay) => {\n  const lastRun = useRef(Date.now())\n\n  return useCallback(\n    (...args) => {\n      if (Date.now() - lastRun.current >= delay) {\n        callback(...args)\n        lastRun.current = Date.now()\n      }\n    },\n    [callback, delay]\n  )\n}\n\n/**\n * Custom hook for local storage with SSR support\n * @param {string} key - Storage key\n * @param {any} initialValue - Initial value\n * @returns {[any, Function]} [value, setValue]\n */\nexport const useLocalStorage = (key, initialValue) => {\n  const [storedValue, setStoredValue] = useState(() => {\n    if (typeof window === 'undefined') {\n      return initialValue\n    }\n    try {\n      const item = window.localStorage.getItem(key)\n      return item ? JSON.parse(item) : initialValue\n    } catch (error) {\n      console.warn(`Error reading localStorage key \"${key}\":`, error)\n      return initialValue\n    }\n  })\n\n  const setValue = useCallback(\n    (value) => {\n      try {\n        const valueToStore = value instanceof Function ? value(storedValue) : value\n        setStoredValue(valueToStore)\n        if (typeof window !== 'undefined') {\n          window.localStorage.setItem(key, JSON.stringify(valueToStore))\n        }\n      } catch (error) {\n        console.warn(`Error setting localStorage key \"${key}\":`, error)\n      }\n    },\n    [key, storedValue]\n  )\n\n  return [storedValue, setValue]\n}\n\n/**\n * Custom hook for previous value\n * @param {any} value - Current value\n * @returns {any} Previous value\n */\nexport const usePrevious = (value) => {\n  const ref = useRef()\n  useEffect(() => {\n    ref.current = value\n  })\n  return ref.current\n}\n\n/**\n * Custom hook for toggle state\n * @param {boolean} initialValue - Initial boolean value\n * @returns {[boolean, Function, Function, Function]} [value, toggle, setTrue, setFalse]\n */\nexport const useToggle = (initialValue = false) => {\n  const [value, setValue] = useState(initialValue)\n\n  const toggle = useCallback(() => setValue(v => !v), [])\n  const setTrue = useCallback(() => setValue(true), [])\n  const setFalse = useCallback(() => setValue(false), [])\n\n  return [value, toggle, setTrue, setFalse]\n}\n\n/**\n * Custom hook for async operations\n * @param {Function} asyncFunction - Async function to execute\n * @returns {Object} { execute, loading, error, data }\n */\nexport const useAsync = (asyncFunction) => {\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState(null)\n  const [data, setData] = useState(null)\n\n  const execute = useCallback(\n    async (...args) => {\n      try {\n        setLoading(true)\n        setError(null)\n        const result = await asyncFunction(...args)\n        setData(result)\n        return result\n      } catch (err) {\n        setError(err)\n        throw err\n      } finally {\n        setLoading(false)\n      }\n    },\n    [asyncFunction]\n  )\n\n  return { execute, loading, error, data }\n}\n\n/**\n * Custom hook for intersection observer\n * @param {Object} options - Intersection observer options\n * @returns {[Function, boolean]} [ref, isIntersecting]\n */\nexport const useIntersectionObserver = (options = {}) => {\n  const [isIntersecting, setIsIntersecting] = useState(false)\n  const [element, setElement] = useState(null)\n\n  const ref = useCallback((node) => {\n    setElement(node)\n  }, [])\n\n  useEffect(() => {\n    if (!element) return\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        setIsIntersecting(entry.isIntersecting)\n      },\n      options\n    )\n\n    observer.observe(element)\n\n    return () => {\n      observer.disconnect()\n    }\n  }, [element, options])\n\n  return [ref, isIntersecting]\n}\n\n/**\n * Custom hook for window size\n * @returns {Object} { width, height }\n */\nexport const useWindowSize = () => {\n  const [windowSize, setWindowSize] = useState({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  })\n\n  useEffect(() => {\n    const handleResize = () => {\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      })\n    }\n\n    window.addEventListener('resize', handleResize)\n    return () => window.removeEventListener('resize', handleResize)\n  }, [])\n\n  return windowSize\n}\n\n/**\n * Custom hook for click outside\n * @param {Function} handler - Function to call when clicked outside\n * @returns {Object} ref - Ref to attach to element\n */\nexport const useClickOutside = (handler) => {\n  const ref = useRef()\n\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (ref.current && !ref.current.contains(event.target)) {\n        handler()\n      }\n    }\n\n    document.addEventListener('mousedown', handleClickOutside)\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside)\n    }\n  }, [handler])\n\n  return ref\n}